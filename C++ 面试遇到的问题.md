# C++ 面试遇到的问题

### 1.创建空类的时候编译器会为空类生成些什么

- **缺省构造函数**，应该就是默认构造函数，不带参数的那种
- **拷贝构造函数**，这是一种特殊的构造函数，参数是该类型的引用，用来将引用的对象复制给新的实例。这里涉及到**深复制**与**浅复制**的问题，默认生成的是**浅复制**的，即将类型包含的所有成员变量复制到新实例里面。这将会构成问题，因为浅复制不会更改静态成员变量，也不会new新的内存空间。
- **析构函数**
- **赋值运算符**，就是=
- **带const的与不带const的取址运算符**，即&

(我不知道是不是C++版本相差甚远，在“深度探索C++对象原理”这本书中提到，编译器不一定会生成甚至调用析构函数，因为有一些情况下析构并无意义)



### 2.有3个类 A B C，B继承A、包含C类型的成员变量，创建B实例的时候调用构造函数的顺序是？

顺序是A C B。

创建实例时**构造函数**的调用顺序是：

- **虚拟基类**的构造函数（virtual public xxx）
- **非虚拟基类**的构造函数
- **成员变量**的构造函数
- **本身**的构造函数

每一种都是按声明时的顺序。

析构则是发过来，结合栈来理解。

引用：https://blog.csdn.net/udahci/article/details/93463468


### 3.虚函数

虚函数是用来实现**多态**的方法，即调用方法的行为取决于调用方法的对象。需要实现多态的基类函数前加virtual来声明虚函数，这样基类指针指向的实例就会按照实际类型执行该函数。

具体实现是编译器在有虚函数的类的成员变量前隐式创建一张**虚函数**表，里面存储着指向虚函数的地址，之后的所有子类都会继承这张表。如果子类重写了其中的函数，则虚函数列表了面对应的位置就会改为子类的函数。当然，这种虚函数表不是存储在实例里，而是在代码区。每个实例仅存储一个**指向虚表的指针**（4byte）。

**虚析构函数**是必须的，因为析构时需要按照子类的析构函数析构而不是父类的析构函数！

实际上在构造函数和析构函数中虚表指针会一直变化。



### 4. 右值引用

**左值**是指表达式结束后依然存在的持久化对象，**右值**是指表达式结束时就不再存在的临时对象。

区别就是&能够作用于左值，例如

```
int a = 10; 
int& refA = a; 
int& b= a+1;//error a+1是右值
```

这样refA相当于a的别名，修改refA相当于修改a

而c++11新增右值引用&&

```
int &&a=1;
int &&b=a;//error a是左值
```

但是有个奇葩

```
const int & a=1;
```

这一句不会报错

可以实现移动语义，考虑以下代码

```c++
vector<string> allcaps(const vector<string> & in){
    vector<string> temp(in);
    retrun temp;
}

int main(){
    vector<string> a;
    vector<string> b(a);
    vector<string> c(allcaps(a));
}
```

b会调用复制构造函数，把a的全部值复制到b，这很好理解，但c呢？，c需要执行两次复制构造函数，一次是temp的，一次是c的。这似乎很没有效率，特别是数组大小很大的时候。换个思路，既然temp是一个临时变量，一旦执行完函数就要作为左值销毁了，那要是c能够直接“占有”temp的内容，那不就只用复制一次了吗？这个就是移动语义。实际上编译器优化时确实会这么干，但是我们并不确定编译器会不会优化每一个这样的地方，因此我们需要自己控制。于是c++11就添加了右值引用。



### 5.重载运算符++

```c++
class A{
public:
	int a;
	A& operate++(){
		a++;
		return this;
	}
	A operate++(int){
		A temp(a);
		a++;
		return temp;
	}
}
```

### 6.多态

- 静多态：**函数重载**、**函数模板**
- 动多态：**继承中的多态**。




### 7.algorithm里面sort用的是哪个排序

sort主要使用**快速排序**，并且使用**插入排序**和**堆排序**进行优化。

快速排序处理大量数据时平均复杂度低，但是有可能因为基值的选取问题造成退化导致递归过深，因此：

- 当**元素规模**小于阈值_S_threshold（一般是16）时，改用**插入排序**
- 当**递归调用次数**超过限制，改用**堆排序**
- 两种情况外才是**快速排序**，分段递归

### 8.迭代器

**迭代器**是一种检查容器内元素并遍历元素的数据类型。C++更趋向于使用迭代器而不是下标操作，因为标准库为每一种标准容器（如vector）定义了一种迭代器类型，而只用少数容器（如vector）支持下标操作访问容器元素。

声明方式：

```
vector<int>    ivec;
vector<int>::iterator    iter; 
vector<int>::iterator     iter2=ivec.begin();
```

常规操作：

```
*iter;             	   //对iter进行解引用，返回迭代器iter指向的元素的引用
iter->men;         	   //对iter进行解引用，获取指定元素中名为men的成员。等效于(*iter).men
++iter;                //给iter加1，使其指向容器的下一个元素
iter++;
--iter;          	   //给iter减1，使其指向容器的前一个元素
iter--;
iter1==iter2;      	  //比较两个迭代器是否相等，当它们指向同一个容器的同一个元素或者都指向同同一个容器的超出末端的下一个位置时，它们相等 
iter1!=iter2;
```

另外，vector 和 queue提供以下运算关系：

```
iter+n     //在迭代器上加（减）整数n，将产生指向容器中钱前面（后面）第n个元素的迭代器。新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一个元素
iter-n

iter1+=iter2        //将iter1加上或减去iter2的运算结果赋给iter1。两个迭代器必须指向容器中的元素或超出容器末端的下一个元素
iter1-=iter2

iter1-iter2            //两个迭代器的减法，得出两个迭代器的距离。两个迭代器必须指向容器中的元素或超出容器末端的下一个元素

>,>=,<,<=        //元素靠后的迭代器大于靠前的迭代器。两个迭代器必须指向容器中的元素或超出容器末端的下一个元素
```

**const_iterator** 只允许读，不允许写

**迭代器失效**：

1. 对于序列式容器，如vector、queue，删除元素会导致后面元素向前移动，因此迭代器会失效。而erase会返回下一个有效迭代器，所以在循环中删除操作应该这样：

   ```
   iter=a.erase(iter);
   ```

   

2. 关联容器如map、set，并不是使用连续的数据结构存储元素，因此删除当前元素仅仅会导致当前迭代器失效，但是erase此时的返回值是void。所以如果是在循环中则需要先递增再删除。

   ```
   a.erase(iter++);//此时原来位置上的元素已经删除，而iter指向下一个元素
   ```

   

3. 对于链表式容器如list，删除当前元素也仅仅会使当前迭代器失效。同时erase也会返回下一个节点的迭代器，因为上述两者均能使用。

   ```
   iter=a.erase(iter);//可
   a.erase(iter++);//亦可
   ```



### 9.智能指针

```
shared_ptr:  
class shared_ptr{
public:
...
private:
T* _ptr;
int *_refCount;
}
```

**shared_ptr**是通过类实现的，类成员为一个指向目标的指针和一个对象实例化的计数器，当q计数器**归零**时，shared_ptr自动销毁



### 10.extern关键字

​	extern是C的关键字，作用是声明变量。变量是分声明和定义阶段的，和函数一样，如果只声明不定义的话，编译器并不会为该变量提供空间。

```
int a;			//声明并且定义
int b=0;		//声明、定义并且初始化
extern int c;	//仅仅是声明
```

​	这样就可以实现变量的跨文件传递，如果全局变量使用extern 声明，则这个变量对外部是可见的。

​	**extern "C"** 这个是c++为了调用C接口的声明方法。因为C++实现了函数重载，编译之后的函数命名规则与C不一致，因此直接链接会找不到该函数，这时候加上这个关键词，就是在说明这个头文件/函数是以C的规则编译，即可调用。

```c
/*这里是C的头文件Clib.h*/
extern int add(int a,int b);
```

```c
/*这里是C的实现文件Clib.c*/
#include"Clib.h"
int add(int a,int b){
	return a+b;
}
```

```c++
/*这里是C++调用C接口的文件CppMain.cpp*/
extern "C"{
	#include"Clib.h"
}
int main(){
	add(1,1);
	return 0;
}
```

上述cpp中如果没有这个关键词，链接的时候会报错找不到add。

另外，如果是C调用C++的接口也类似

```c++
/*C++库 cpplib.h*/
extern "C" int add(int a,int b);
```

```c
/*c中调用，这里是cFile.c*/
extern int add(int a,int b);
int main(){
	add(1,1);
	return 0;
}
```






## 以下是实习期间总结的C++相关知识

1.	当不使用容器例如vector传递数组时，例如int[xxx]传入形参时实际上会退化成指针int*，这时候并无法知道其正确大小，而且因为指针的关系，数组越界也不会报错，甚至可能访问到错误内存。这时候可以形参设置为std::span<T>，提供了保护，能够检查越界错误。
	
2.	匿名命名空间即 namespace {} 不命名，这个空间内的变量相当于static，外部文件访问不到。

3.	X()=default, 编译器会自动构造默认的构造函数，而=delete则可以禁止编译器自动生成转换构造函数、拷贝构造函数甚至是操作符new，即可以禁止一些程序员不希望出现的操作，例如自动的类型转换。=delete的作用范围更广，甚至可以作用于删除非成员函数，例如某个具有模板类的函数，我们不希望模板被套为某特定类型时，可以使用这个关键字删除特定函数。
```
template<typename T>
void Fun(T value);

template<>
void Fun<int>(int)=delete;
```

4.	不要在构造函数和析构函数中调用虚函数，因为这两个阶段类型实际上是会发生变化的，这时候的虚函数就不会展现出多态特性。

5.	不要在虚函数中使用缺省默认值，因为缺省默认值是在编译时静态绑定，因此不会有多态特性。

6.	函数体后面声明noexcept可以让编译器给这段函数最大的程度优化，但是要保证函数体内不需要抛出或截获异常

7.	使用using代替typedef，using在C++11后能够实现声明别名，例如using INTSET=set<int>，比typedef更加清晰而且还能支持模板类。
```
template<class T>
using TMAP=map<T,int>;
```

8.	std::variant<type,type…>可提供相当于联合体union的作用，可充当不定类型的函数参数，成员函数index()可以判断改实例属于那种类型（C++17新增）
9.	类型转换dynamic_cast是下行转换即父类转子类，static_cast通常用于普通类型的强制转换，reinterpret_cast是不相关类型的转换、编译器会强制将某类型对象内存解释成另一对象、可见其不安全，const_cast能够移除const属性。

